<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Graduate Descent - machine-learning</title><link href="https://timvieira.github.io/blog/" rel="alternate"></link><link href="/blog/feeds/tag/machine-learning.atom.xml" rel="self"></link><id>https://timvieira.github.io/blog/</id><updated>2019-04-20T00:00:00-04:00</updated><entry><title>The likelihood-ratio gradient</title><link href="https://timvieira.github.io/blog/post/2019/04/20/the-likelihood-ratio-gradient/" rel="alternate"></link><published>2019-04-20T00:00:00-04:00</published><updated>2019-04-20T00:00:00-04:00</updated><author><name>Tim Vieira</name></author><id>tag:timvieira.github.io,2019-04-20:/blog/post/2019/04/20/the-likelihood-ratio-gradient/</id><content type="html">&lt;p&gt;&lt;strong&gt;Setup&lt;/strong&gt;: We're trying to optimize a function of the form&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) = \underset{p_\theta}{\mathbb{E}} \left[ r(x) \right] = \sum_{x \in \mathcal{X}} p_\theta(x) r(x).
$$&lt;/div&gt;
&lt;p&gt;The problem is that we can't just evaluate each &lt;span class="math"&gt;\(x \in \mathcal{X}\)&lt;/span&gt; because we
don't have complete knowledge of &lt;span class="math"&gt;\(p_\theta\)&lt;/span&gt;.  For example, it is a mix of
factors that are known and under our control via &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; (policy factors) and
factors that are not known (environment factors).&lt;/p&gt;
&lt;p&gt;Combined with stochastic gradient ascent, the likelihood-ratio gradient estimator is an approach for solving such a
problem.  It appears in policy gradient methods for reinforcement learning
(e.g.,
&lt;a href="https://papers.nips.cc/paper/1713-policy-gradient-methods-for-reinforcement-learning-with-function-approximation.pdf"&gt;Sutton et al. 1999&lt;/a&gt;),
black-box optimization (e.g., &lt;a href="https://arxiv.org/abs/1106.4487"&gt;Wierstra et al. 2011&lt;/a&gt;), and &lt;a href="https://timvieira.github.io/blog/post/2016/12/19/counterfactual-reasoning-and-learning-from-logged-data/"&gt;causal reasoning&lt;/a&gt;. There are two main ideas in the
trick: (1) the "score function" estimator and (2) the cancelation of
complicating factors.&lt;/p&gt;
&lt;h4&gt;Part 1: The score function gradient estimator&lt;/h4&gt;
&lt;p&gt;Suppose we can sample &lt;span class="math"&gt;\(x^{(j)} \sim p_\theta\)&lt;/span&gt;. This opens up the following
(unbiased) Monte Carlo estimators for &lt;span class="math"&gt;\(J\)&lt;/span&gt; and its gradient,&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) \approx \frac{1}{m} \sum_{j=1}^m r(x^{(j)})
$$&lt;/div&gt;
&lt;div class="math"&gt;$$
\nabla_{\!\theta} J(\theta) \approx \frac{1}{m} \sum_{j=1}^m r(x^{(j)}) \nabla_{\!\theta} \log p_{\theta}(x^{(j)}).
$$&lt;/div&gt;
&lt;p&gt;The derivation is pretty simple
&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
  \nabla_{\!\theta} \, \underset{p_\theta}{\mathbb{E}}\left[ r(x) \right]
  &amp;amp;=&amp;amp; \nabla_{\!\theta} \left[ \sum_x p_{\theta}(x) r(x) \right] \\
  &amp;amp;=&amp;amp; \sum_x \nabla_{\!\theta} \left[ p_{\theta}(x) \right] r(x) \\
  &amp;amp;=&amp;amp; \sum_x p_{\theta}(x) \frac{\nabla_{\!\theta} \left[ p_{\theta}(x) \right] }{ p_{\theta}(x) } r(x) \\
  &amp;amp;=&amp;amp; \underset{p}{\mathbb{E}}\left[ r(x) \nabla_{\!\theta} \log p_\theta(x) \right]
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;
We use the identity &lt;span class="math"&gt;\(\nabla f = f\, \nabla \log f\)&lt;/span&gt;, assuming &lt;span class="math"&gt;\(f &amp;gt; 0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To use this estimator, we only need two things (1) the ability to sample
&lt;span class="math"&gt;\(x^{(j)} \sim p_{\theta}\)&lt;/span&gt;, (2) the ability to evaluate &lt;span class="math"&gt;\(\log
p_{\theta}(x^{(j)})\)&lt;/span&gt; and &lt;span class="math"&gt;\(r(x^{(j)})\)&lt;/span&gt; for each sampled value.&lt;/p&gt;
&lt;p&gt;This isn't even the entire method, but we can already use it to do some neat
things.  For example, minimum risk training of structured prediction models.
Assuming we can obtain good samples&amp;mdash;preferably exact samples, but MCMC
samples might be ok&amp;mdash;the likelihood ratio can help us learning even with
complicated blackbox cost functions (sometimes called "nondecomposable loss
functions") like human annotators or impenetrable perl scripts. I had this idea
back in 2012, but never got around to pushing it out. There appear to be some
papers that picked up on this idea, including
&lt;a href="http://www.cl.uni-heidelberg.de/~riezler/publications/papers/ACL2016.pdf"&gt;Sokolov et al. (2016)&lt;/a&gt;
and &lt;a href="https://arxiv.org/abs/1609.00150"&gt;Norouzi et al. (2016)&lt;/a&gt; and even a few
papers using it for "black box" variational inference
&lt;a href="https://arxiv.org/abs/1401.0118"&gt;(Ranganath et al., 2013)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Remarks:&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Relaxing discrete actions into stochastic ones&lt;/strong&gt;: A common way to handle
   discrete decisions is to put a &lt;em&gt;differentiable&lt;/em&gt; parametric density (like
   &lt;span class="math"&gt;\(p_\theta\)&lt;/span&gt;) over the space of possible executions (paths &lt;span class="math"&gt;\(x\)&lt;/span&gt;). (Note: this
   shouldn't be surprising&amp;mdash;it's already what we do in structured
   prediction methods like conditional random fields!)  The likelihood-ratio
   method can be used to estimate gradients in such settings.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bandit feedback&lt;/strong&gt;: This approach naturally handles "bandit feedback"
   (partial information about &lt;span class="math"&gt;\(r\)&lt;/span&gt;): you only see the values of only the
   trajectories that you actually sample. In contrast with "full information",
   which tells you the reward of all possible trajectories.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;The off-policy estimator&lt;/h5&gt;
&lt;p&gt;Let's generalize this estimator to allow off-policy actions
&lt;a href="https://timvieira.github.io/blog/post/2014/12/21/importance-sampling/"&gt;importance-weighted estimator&lt;/a&gt;. Here
&lt;span class="math"&gt;\(q\)&lt;/span&gt; is a distribution over the same space as &lt;span class="math"&gt;\(p\)&lt;/span&gt; with support at least
everywhere &lt;span class="math"&gt;\(p\)&lt;/span&gt; has support.  &lt;/p&gt;
&lt;div class="math"&gt;$$ \begin{eqnarray*} \nabla_{\!\theta} \,
\underset{p_\theta}{\mathbb{E}}\left[ r(x) \right] &amp;amp;=&amp;amp;
\underset{p}{\mathbb{E}}\left[ r(x) \nabla_{\!\theta} \log p_\theta(x) \right]
\\ &amp;amp;=&amp;amp; \sum_x p_{\theta}(x) r(x) \nabla_{\!\theta} \log p_\theta(x) \\ &amp;amp;=&amp;amp;
\sum_x \frac{q(x)}{q(x)} p_{\theta}(x) r(x) \nabla_{\!\theta} \log p_\theta(x)
\\ &amp;amp;=&amp;amp;
\underset{q}{\mathbb{E}}\left[ \frac{p_{\theta}(x)}{q(x)} r(x) \nabla_{\!\theta} \log p_\theta(x) \right]
\\ &amp;amp;\approx&amp;amp; \frac{1}{n} \sum_{i=1}^n \frac{p_{\theta}(x^{(i)})}{q(x^{(i)})} r(x^{(i)}) \nabla_{\!\theta} \log p_\theta(x^{(i)})\quad \text{ where } x^{(i)} \sim q
\end{eqnarray*} $$&lt;/div&gt;
&lt;p&gt;Note that we recover the original estimator when &lt;span class="math"&gt;\(q=p\)&lt;/span&gt;.&lt;/p&gt;
&lt;h4&gt;Part 2: The convenient cancelation of complicating components&lt;/h4&gt;
&lt;p&gt;The real power of the &lt;em&gt;likelihood-ratio&lt;/em&gt; part of this method comes when you have
the ability to sample &lt;span class="math"&gt;\(x\)&lt;/span&gt;, but &lt;em&gt;not&lt;/em&gt; the ability to compute the probability of
&lt;em&gt;all&lt;/em&gt; factors of the joint probability of &lt;span class="math"&gt;\(x\)&lt;/span&gt; (i.e., you can't compute the
&lt;em&gt;complete&lt;/em&gt; score &lt;span class="math"&gt;\(p_{\theta}(x)\)&lt;/span&gt;). In other words, some components of the joint
probability's &lt;em&gt;generative process&lt;/em&gt; might pass through factors which are &lt;em&gt;only
accessible through sampling&lt;/em&gt;, e.g., because they require performing &lt;em&gt;actual
experiments&lt;/em&gt; in the real world or a complex simulation! The factors that we can
only sample from are what make this a true stochastic optimization problem.&lt;/p&gt;
&lt;p&gt;Let's be a little more concrete by looking at a classic example from
reinforcement learning: the Markov decision process (MDP). In this context, the
random variable &lt;span class="math"&gt;\(x\)&lt;/span&gt; is an alternating sequence of states and actions, &lt;span class="math"&gt;\(x =
\langle s_0, a_0, s_1, a_1, \ldots a_{T-1}, s_T \rangle\)&lt;/span&gt; and the generative
process consists of an unknown transition function &lt;span class="math"&gt;\(p(s_{t+1}|s_t,a_t)\)&lt;/span&gt; that is
only accessible through sampling and a policy &lt;span class="math"&gt;\(p_{\theta}(a_t|s_t)\)&lt;/span&gt; which we in
control of. So the probability of an entire sequence in an MDP &lt;span class="math"&gt;\(p_{\theta}(x)\)&lt;/span&gt;
is &lt;span class="math"&gt;\(p(s_0) \prod_{t=0}^T p(s_{t+1}|s_t,a_t) \pi_\theta(a_t|s_t)\)&lt;/span&gt;. The
likelihood-ratio method can be used to derive several "policy gradient" methods,
which compute unbiased gradient estimates with no knowledge of the transition
distribution.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The beauty of the likelihood ratio is the cancellation of unknown terms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Aside: This fortunate cancellation occurs in many other contexts, e.g. the
Metropolis-Hastings accept-reject criteria.&lt;/p&gt;
&lt;p&gt;To make this explicit, let's consider the importance weight, &lt;span class="math"&gt;\(p/q\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{eqnarray}
\frac{p_\theta(x)}{q(x)}
= \frac{ {\color{red}{ p(s_0) }} \prod_{t=0}^T {\color{red}{ p(s_{t+1}|s_t,a_t) }} \pi_\theta(a_t|s_t) }
       { {\color{red}{ p(s_0) }} \prod_{t=0}^T {\color{red}{ p(s_{t+1}|s_t,a_t) }}  q(a_t|s_t) }
= \frac{\prod_{t=0}^T \pi_\theta(a_t|s_t)}
       {\prod_{t=0}^T q(a_t|s_t)}
\end{eqnarray}&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;
Common terms cancel! This implies that we don't need to compute them.&lt;/p&gt;
&lt;p&gt;Those component cancel in &lt;span class="math"&gt;\(\nabla_{\!\theta} \log p_{\theta}(x)\)&lt;/span&gt; because terms
that do not depend on &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; also disappear. Leaving you with just a sum of
log-gradient terms that you &lt;em&gt;do&lt;/em&gt; know because they are part of the model you're
tuning.&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
\nabla \log p(x)
&amp;amp;=&amp;amp; \nabla \log \left( p(s_0) \prod_{t=0}^T p(s_{t+1}|s_t,a_t) \pi_\theta(a_t|s_t) \right) \\
&amp;amp;=&amp;amp; \nabla \left(\log p(s_0) + \sum_{t=0}^T \log p(s_{t+1}|s_t,a_t)
  + \log \pi_\theta(a_t|s_t) \right) \\
&amp;amp;=&amp;amp; \sum_{t=0}^T \nabla \log \pi_\theta(a_t|s_t)
\end{eqnarray*}
$$&lt;/div&gt;
&lt;h4&gt;The baseline trick&lt;/h4&gt;
&lt;p&gt;These estimators should always be used in conjunction with a baseline function
or more generally a control variate. There are many options for deriving control
variates, which will depend on the specific structure of &lt;span class="math"&gt;\(x\)&lt;/span&gt;.  For example, in
the MDP case, we can use any function that depends on &lt;span class="math"&gt;\(s_t\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;However, even without special structure, we can an always should use (at a
minimum) a constant baseline,
&lt;/p&gt;
&lt;div class="math"&gt;$$
\mathbb{E}_{x \sim q} \left[
\frac{p_{\theta}(x)}{q(x)}
r(x)
\nabla_{\!\theta} \log p_\theta(x)
\right]
=
\mathbb{E}_{x \sim q} \left[
\frac{p_{\theta}(x)}{q(x)}
(r(x) - {\color{red}{b}})
\nabla_{\!\theta} \log p_\theta(x)
\right]
\text{for all } {\color{red}{b} \in \mathbb{R}}
$$&lt;/div&gt;
&lt;p&gt;
The minimum variance choice for b is
&lt;/p&gt;
&lt;div class="math"&gt;$$
b = \frac{\sum_k \mathrm{Cov}(r, \nabla_{\theta_k} \log p) }{\sum_k \mathrm{Var}(\nabla_{\theta_k} \log p) }
$$&lt;/div&gt;
&lt;p&gt;
which we can compute with sampling-based estimators of the quantities.&lt;/p&gt;
&lt;p&gt;Some folks use an estimate of &lt;span class="math"&gt;\(J\)&lt;/span&gt;, which is better than nothing.&lt;/p&gt;
&lt;h4&gt;Important points&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Always use a baseline.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This gradient estimate is "zero order" it is essentially probing the function
   in &lt;span class="math"&gt;\(x\)&lt;/span&gt; space, which might be higher dimensional than &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;. As a result,
   you might be better off with gradient estimators that are based on perturbing
   &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; directly, e.g., zeroth-order methods (sometimes called &lt;em&gt;direct
   search&lt;/em&gt; or &lt;em&gt;gradient-free&lt;/em&gt; optimization methods) like Nelder-Mead simplex,
   FDSA, SPSA, and CMA-ES.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Often there is almost no signal. Consider the example of trying to solve a
   maze by randomly running around in it.  In this case, it's very unlikely that
   a random path will lead to a positive outcome.  Therefore, the gradient
   really is essentially zero. So even with access to the &lt;em&gt;true&lt;/em&gt; gradient (i.e.,
   no variance), optimization would have a lot of trouble finding a good
   optimum.  Add to that some variance and you have useless on top of noisy.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Although the likelihood-ratio gives us an unbiased estimate of the gradient,
   don't be fooled. The particular gradient estimate used in the
   likelihood-ratio method has an impractical signal-to-noise ratio, which makes
   it very hard use in optimization.  There are countless papers on tricks to
   reduce the variance of the estimator.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;You can improve your data efficiency and algorithm stability using off-line
   optimization (with your favorite deterministic optimization algorithm).  I
   have written a long article about offline optimization
   &lt;a href="https://timvieira.github.io/blog/post/2016/12/19/counterfactual-reasoning-and-learning-from-logged-data/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;There is still a lot to say about likelihood-ratio methods.  I didn't talk about
control variates or "baseline" functions, which are very important to making
things work.  I'll try to post my notes on those ideas soon.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Take home messages&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If you can evaluate it, then you can take the gradient of it (assuming it
   exists). This even holds if the evaluation is based on Monte Carlo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The likelihood-ratio shows up all over the place, not just RL. It shows up in
   &lt;a href="https://timvieira.github.io/blog/post/2016/12/19/counterfactual-reasoning-and-learning-from-logged-data/"&gt;causal reasoning&lt;/a&gt;
   more generally.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We described a general way to learn from watching someone else act in a world
   we don't understand (i.e., off-policy learning with no knowledge of the
   environment just samples!). The only catch is that in order for us to learn
   from them we need them to do a little bit of "exploration" (i.e., be a
   stochastic policy that has support everywhere we do) and tell us their action
   probabilities (so that we can important weight against our policy).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="misc"></category><category term="optimization"></category><category term="rl"></category><category term="machine-learning"></category></entry><entry><title>Counterfactual reasoning and learning from logged data</title><link href="https://timvieira.github.io/blog/post/2016/12/19/counterfactual-reasoning-and-learning-from-logged-data/" rel="alternate"></link><published>2016-12-19T00:00:00-05:00</published><updated>2016-12-19T00:00:00-05:00</updated><author><name>Tim Vieira</name></author><id>tag:timvieira.github.io,2016-12-19:/blog/post/2016/12/19/counterfactual-reasoning-and-learning-from-logged-data/</id><content type="html">&lt;style&gt; .toggle-button { background-color: #555555; border: none; color: white;
padding: 10px 15px; border-radius: 6px; text-align: center; text-decoration:
none; display: inline-block; font-size: 16px; cursor: pointer; } .derivation {
background-color: #f2f2f2; border: thin solid #ddd; padding: 10px;
margin-bottom: 10px; } &lt;/style&gt;

&lt;script&gt;
/* workaround for when markdown/mathjax gets confused by the javascript dollar function. */
function toggle(x) { $(x).toggle(); }
&lt;/script&gt;

&lt;p&gt;Counterfactual reasoning is &lt;em&gt;reasoning about data that we did not observe&lt;/em&gt;. For
example, reasoning about the expected reward of new policy given data collected
from a older one.&lt;/p&gt;
&lt;p&gt;In this post, I'll discuss some basic techniques for learning from logged
data. For the large part, this post is based on things I learned from
&lt;a href="http://www.cs.ucr.edu/~cshelton/papers/docs/icml02.pdf"&gt;Peshkin &amp;amp; Shelton (2002)&lt;/a&gt;
and &lt;a href="https://arxiv.org/abs/1209.2355"&gt;Bottou et al. (2013)&lt;/a&gt; (two of my all-time
favorite papers).&lt;/p&gt;
&lt;p&gt;After reading, have a look at the
&lt;a href="https://gist.github.com/timvieira/788c2c25c94663c49abada60f2e107e9"&gt;Jupyter notebook&lt;/a&gt;
accompanying this post!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Setup&lt;/strong&gt; (&lt;em&gt;off-line off-policy optimization&lt;/em&gt;): We're trying to optimize a
function of the form,&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta) = \underset{p_\theta}{\mathbb{E}} \left[ r(x) \right] = \sum_{x \in \mathcal{X}} p_\theta(x) r(x).
$$&lt;/div&gt;
&lt;p&gt;&lt;br/&gt; But! We only have a &lt;em&gt;fixed&lt;/em&gt; sample of size &lt;span class="math"&gt;\(m\)&lt;/span&gt; from a data collection
policy &lt;span class="math"&gt;\(q\)&lt;/span&gt;, &lt;span class="math"&gt;\(\{ (r^{(j)}, x^{(j)} ) \}_{j=1}^m \overset{\text{i.i.d.}} \sim q.\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Although, it's not &lt;em&gt;necessarily&lt;/em&gt; the case, you can think of &lt;span class="math"&gt;\(q = p_{\theta'}\)&lt;/span&gt;
  for a &lt;em&gt;fixed&lt;/em&gt; value &lt;span class="math"&gt;\(\theta'.\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\mathcal{X}\)&lt;/span&gt; is an arbitrary multivariate space, which permits a mix of
  continuous and discrete components, with appropriate densities, &lt;span class="math"&gt;\(p_{\theta}\)&lt;/span&gt;
  and &lt;span class="math"&gt;\(q\)&lt;/span&gt; defined over it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(r: \mathcal{X} \mapsto \mathbb{R}\)&lt;/span&gt; is a black box that outputs a scalar
  score.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I've used the notation &lt;span class="math"&gt;\(r^{(j)}\)&lt;/span&gt; instead of &lt;span class="math"&gt;\(r(x^{(j)})\)&lt;/span&gt; to emphasize that we
  can't evaluate &lt;span class="math"&gt;\(r\)&lt;/span&gt; at &lt;span class="math"&gt;\(x\)&lt;/span&gt; values other than those in the sample.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We'll assume that &lt;span class="math"&gt;\(q\)&lt;/span&gt; assigns positive probability everywhere, &lt;span class="math"&gt;\(q(x) &amp;gt; 0\)&lt;/span&gt; for
  all &lt;span class="math"&gt;\(x \in \mathcal{X}\)&lt;/span&gt;. This means is that the data collection process must
  be randomized and eventually sample all possible configurations. Later, I
  discuss relaxing this assumption.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each distribution is a product of one or more factors of the following types:
&lt;strong&gt;policy factors&lt;/strong&gt; (at least one), which directly depend on &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;, and
&lt;strong&gt;environment factors&lt;/strong&gt; (possibly none), which do not depend directly on
&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;. Note that environment factors are &lt;em&gt;only&lt;/em&gt; accessible via sampling
(i.e., we don't know the &lt;em&gt;value&lt;/em&gt; they assign to a sample). For example, a
&lt;em&gt;contextual bandit problem&lt;/em&gt;, where &lt;span class="math"&gt;\(x\)&lt;/span&gt; is a context-action pair, &lt;span class="math"&gt;\(x =
(s,a)\)&lt;/span&gt;. Here &lt;span class="math"&gt;\(q(x) = q(a|s) p(s)\)&lt;/span&gt; and &lt;span class="math"&gt;\(p_{\theta}(x) = p_{\theta}(a|s)
p(s)\)&lt;/span&gt;. Note that &lt;span class="math"&gt;\(p_{\theta}\)&lt;/span&gt; and &lt;span class="math"&gt;\(q\)&lt;/span&gt; share the environment factor &lt;span class="math"&gt;\(p(s)\)&lt;/span&gt;, the
distribution over contexts, and only differ in the action-given-context
factor. For now, assume that we can evaluate all environment factors; later,
I'll discuss how we cleverly work around it.&lt;/p&gt;
&lt;!--
(We can
even extend it to a full-blown MDP or POMDP by taking $x$ to be a sequence of
state-action pairs, often called "trajectories".)
--&gt;

&lt;p&gt;&lt;strong&gt;The main challenge&lt;/strong&gt; of this setting is that we don't have controlled
experiments to learn from because &lt;span class="math"&gt;\(q\)&lt;/span&gt; is not (completely) in our control. This
manifests itself as high variance ("noise") in estimating &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;. Consider
the contextual bandit setting, we receive a context &lt;span class="math"&gt;\(s\)&lt;/span&gt; and execute single
action; we never get to rollback to that precise context and try an alternative
action (to get a paired sample #yolo) because we do not control &lt;span class="math"&gt;\(p(s)\)&lt;/span&gt;. This is
an important paradigm for many 'real world' problems, e.g., predicting medical
treatments or ad selection.&lt;/p&gt;
&lt;!--
This is the crucial difference that makes counterfactual learning
more difficult than (fully) supervised learning.
--&gt;

&lt;p&gt;&lt;strong&gt;Estimating &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;&lt;/strong&gt; [V1]: We obtain an unbiased estimator of &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;
with
&lt;a href="http://timvieira.github.io/blog/post/2014/12/21/importance-sampling/"&gt;importance sampling&lt;/a&gt;,&lt;/p&gt;
&lt;div class="math"&gt;$$
J(\theta)
\approx \hat{J}_{\!\text{IS}}(\theta)
= \frac{1}{m} \sum_{j=1}^m r^{(j)} \!\cdot\! w^{(j)}_{\theta}
\quad \text{ where } w^{(j)}_{\theta} = \frac{p_{\theta}(x^{(j)}) }{ q(x^{(j)}) }.
$$&lt;/div&gt;
&lt;p&gt;&lt;br/&gt; This estimator is remarkable: it uses importance sampling as a function
approximator! We have an &lt;em&gt;unbiased&lt;/em&gt; estimate of &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt; for any value of
&lt;span class="math"&gt;\(\theta\)&lt;/span&gt; that we like. &lt;em&gt;The catch&lt;/em&gt; is that we have to pick &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; a priori,
i.e., with no knowledge of the sample.&lt;/p&gt;
&lt;!--
We also require that the usual 'support
conditions' for importance sampling conditions ($p_{\theta}(x)&gt;0 \Rightarrow
q(x)&gt;0$ for all $x \in \mathcal{X}$, which is why we made assumption A1.
--&gt;

&lt;p&gt;After we've collected a (large) sample it's possible to optimize
&lt;span class="math"&gt;\(\hat{J}_{\!\text{IS}}\)&lt;/span&gt; using any optimization algorithm (e.g., L-BFGS). Of
course, we risk overfitting to the sample if we evaluate
&lt;span class="math"&gt;\(\hat{J}_{\!\text{IS}}\)&lt;/span&gt;. Actually, it's a bit worse: this objective tends to
favor regions of &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;, which are not well represented in the sample because
the importance sampling estimator has high variance in these regions resulting
from large importance weights (when &lt;span class="math"&gt;\(q(x)\)&lt;/span&gt; is small and &lt;span class="math"&gt;\(p_{\theta}(x)\)&lt;/span&gt; is
large, &lt;span class="math"&gt;\(w(x)\)&lt;/span&gt; is large and consequently so is &lt;span class="math"&gt;\(\hat{J}_{\!\text{IS}}\)&lt;/span&gt; regardless
of whether &lt;span class="math"&gt;\(r(x)\)&lt;/span&gt; is high!). Thus, we want some type of "regularization" to keep
the optimizer in regions which are sufficiently well-represented by the sample.&lt;/p&gt;
&lt;!--
**Visual example**: We can visualize this phenomena in a simple example. Let $q
= \mathcal{N}(0, \sigma=5)$, $r(x) = 1 \text{ if } x \in [2, 3], 0.2 \text{
otherwise},$ and $p_\theta = \mathcal{N}(\theta, \sigma=1)$.  This example is
nice because it let's us plot $x$ and $\theta$ in the same space. This is
generally not the case, because $\mathcal{X}$ may have no connection to $\theta$
space, e.g., $\mathcal{X}$ may be discrete.

**TODO** add plot
--&gt;

&lt;p&gt;&lt;strong&gt;Better surrogate&lt;/strong&gt; [V2]: There are many ways to improve the variance of the
estimator and &lt;em&gt;confidently&lt;/em&gt; obtain improvements to the system. One of my
favorites is Bottou et al.'s lower bound on &lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;, which we get by
clipping importance weights, replace &lt;span class="math"&gt;\(w^{(j)}_{\theta}\)&lt;/span&gt; with &lt;span class="math"&gt;\(\min(R,
w^{(j)}_{\theta})\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Confidence intervals&lt;/strong&gt; [V3]: We can augment the V2 lower bound with confidence
intervals derived from the empirical Bernstein bound (EBB). We'll require that
&lt;span class="math"&gt;\(r\)&lt;/span&gt; is bounded and that we know its max/min values. The EBB &lt;em&gt;penalizes&lt;/em&gt;
hypotheses (values of &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;) which have higher sample variance. (Note: a
Hoeffding bound wouldn't change the &lt;em&gt;shape&lt;/em&gt; of the objective, but EBB does
thanks to the sample variance penalty. EBB tends to be tighter.). The EBB
introduces an additional "confidence" hyperparameter, &lt;span class="math"&gt;\((1-\delta)\)&lt;/span&gt;. Bottou et
al. recommend maximizing the lower bound as it provides safer improvements. See
the original paper for the derivation.&lt;/p&gt;
&lt;!--
An important benefit of having upper *and* lower is that the bounds tell
us whether or not we should collect more data
--&gt;

&lt;p&gt;Both V2 and V3 are &lt;em&gt;biased&lt;/em&gt; (as they are lower bounds), but we can mitigate the
bias by &lt;em&gt;tuning&lt;/em&gt; the hyperparameter &lt;span class="math"&gt;\(R\)&lt;/span&gt; on a heldout sample (we can even tune
&lt;span class="math"&gt;\(\delta\)&lt;/span&gt;, if desired). Additionally, V2 and V3 are 'valid' when &lt;span class="math"&gt;\(q\)&lt;/span&gt; has limited
support since they prevent the importance weights from exploding (of course, the
bias can be arbitrarily bad, but probably unavoidable given the
learning-from-only-logged data setup).&lt;/p&gt;
&lt;h2&gt;Extensions&lt;/h2&gt;
&lt;!--
**Be warned**: This may be considered an idealized setting. Much of the research
in counterfactual and causal reasoning targets (often subtle) deviations from
these assumptions (and some different questions, of course). Some extensions and
discussion appear towards the end of the post.
--&gt;

&lt;p&gt;&lt;strong&gt;Unknown environment factors&lt;/strong&gt;: Consider the contextual bandit setting
(mentioned above). Here &lt;span class="math"&gt;\(p\)&lt;/span&gt; and &lt;span class="math"&gt;\(q\)&lt;/span&gt; share an &lt;em&gt;unknown&lt;/em&gt; environment factor: the
distribution of contexts. Luckily, we do not need to know the value of this
factor in order to apply any of our estimators because they are all based on
likelihood &lt;em&gt;ratios&lt;/em&gt;, thus the shared unknown factors cancel out!  Some specific
examples are given below. Of course, these factors do influence the estimators
because they are crucial in &lt;em&gt;sampling&lt;/em&gt;, they just aren't necessary in
&lt;em&gt;evaluation&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In contextual bandit example, &lt;span class="math"&gt;\(x\)&lt;/span&gt; is a state-action pair, &lt;span class="math"&gt;\(w_{\theta}(x) =
    \frac{p_{\theta}(x)}{q(x)} = \frac{ p_{\theta}(s,a) }{ q(s,a) } =
    \frac{p_{\theta}(a|s) p(s)}{q(a|s) p(s)} = \frac{p_{\theta}(a|s) }{ q(a|s)
    }\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In a Markov decision process, &lt;span class="math"&gt;\(x\)&lt;/span&gt; is a sequence of state-action pairs,
    &lt;span class="math"&gt;\(w_{\theta}(x) = \frac{p_{\theta}(x)}{q(x)} = \frac{ p(s_0) \prod_{t=0}^T
    p(s_{t+1}|s_t,a_t) p_\theta(a_t|s_t) } { p(s_0) \prod_{t=0}^T
    p(s_{t+1}|s_t,a_t) q(a_t|s_t) } = \frac{\prod_{t=0}^T \pi_\theta(a_t|s_t)}
    {\prod_{t=0}^T q(a_t|s_t)}.\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Variance reduction&lt;/strong&gt;: These estimators can all be improved with variance
reduction techniques. Probably the most effective technique is using
&lt;a href="https://en.wikipedia.org/wiki/Control_variates"&gt;control variates&lt;/a&gt; (of which
baseline functions are a special case). These are random variables correlated
with &lt;span class="math"&gt;\(r(x)\)&lt;/span&gt; for which we know their expectations (or at least they are estimated
separately). A great example is how ad clicks depend strongly on time-of-day
(fewer people are online late at night so we get fewer clicks), thus the
time-of-day covariate explains a large part of the variation in &lt;span class="math"&gt;\(r(x)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Estimation instead of optimization&lt;/strong&gt;: You can use this general setup for
estimation instead of optimization, in which case it's fine to let &lt;span class="math"&gt;\(r\)&lt;/span&gt; have
real-valued multivariate output. The confidence intervals are probably useful in
that setting too.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unknown &lt;span class="math"&gt;\(q\)&lt;/span&gt;&lt;/strong&gt;: Often &lt;span class="math"&gt;\(q\)&lt;/span&gt; is an existing complex system, which does not record
its probabilities. It is possible to use regression to estimate &lt;span class="math"&gt;\(q\)&lt;/span&gt; from the
samples, which is called the &lt;strong&gt;propensity score&lt;/strong&gt; (PS). PS attempts to account
for &lt;strong&gt;confounding variables&lt;/strong&gt;, which are hidden causes that control variation in
the data. Failing to account for confounding variables may lead to
&lt;a href="https://en.wikipedia.org/wiki/Simpson's_paradox"&gt;incorrect conclusions&lt;/a&gt;. Unfortunately,
PS results in a biased estimator because we're using a 'ratio of expectations'
(we'll divide by the PS estimate) instead of an 'expectation of ratios'. PS is
only statistically consistent in the (unlikely) event that the density estimate
is correctly specified (i.e., we can eventually get &lt;span class="math"&gt;\(q\)&lt;/span&gt; correct). In the unknown
&lt;span class="math"&gt;\(q\)&lt;/span&gt; setting, it's often better to use the &lt;strong&gt;doubly-robust estimator&lt;/strong&gt; (DR) which
combines &lt;em&gt;two&lt;/em&gt; estimators: a density estimator for &lt;span class="math"&gt;\(q\)&lt;/span&gt; and a function
approximation for &lt;span class="math"&gt;\(r\)&lt;/span&gt;. A great explanation for the bandit case is in
&lt;a href="https://arxiv.org/abs/1103.4601"&gt;Dudík et al. (2011)&lt;/a&gt;. The DR estimator is also
biased, but it has a better bias-variance tradeoff than PS.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What if &lt;span class="math"&gt;\(q\)&lt;/span&gt; doesn't have support everywhere?&lt;/strong&gt; This is an especially important
setting because it is often the case that data collection policies abide by some
&lt;strong&gt;safety regulations&lt;/strong&gt;, which prevent known bad configurations. In many
situations, evaluating &lt;span class="math"&gt;\(r(x)\)&lt;/span&gt; corresponds to executing an action &lt;span class="math"&gt;\(x\)&lt;/span&gt; in the real
world so terrible outcomes could occur, such as, breaking a system, giving a
patient a bad treatment, or losing money. V1 is ok to use as long as we satisfy
the importance sampling support conditions, which might mean rejecting certain
values for &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; (might be non-trivial to enforce) and consequently finding a
less-optimal policy. V2 and V3 are ok to use without an explicit constraint, but
additional care may be needed to ensure specific safety constraints are
satisfied by the learned policy.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;What if &lt;span class="math"&gt;\(q\)&lt;/span&gt; is deterministic?&lt;/strong&gt; This is related to the point above. This is a
hard problem. Essentially, this trying to learn without any exploration /
experimentation! In general, we need exploration to learn. Randomization isn't
the only way to perform exploration, there are many systematic types of
experimentation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There are some cases of systematic experimentation that are ok. For example,
    enumerating all elements of &lt;span class="math"&gt;\(\mathcal{X}\)&lt;/span&gt; (almost certainly
    infeasible). Another example is a contextual bandit where &lt;span class="math"&gt;\(q\)&lt;/span&gt; assigns
    actions to contexts deterministically via a hash function (this setting is
    fine because &lt;span class="math"&gt;\(q\)&lt;/span&gt; is essentially a uniform distribution over actions, which
    is independent of the state). In other special cases, we &lt;em&gt;may&lt;/em&gt; be able to
    characterize systematic exploration as
    &lt;a href="https://en.wikipedia.org/wiki/Stratified_sampling"&gt;stratified sampling&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A generic solution might be to apply the doubly-robust estimator, which
    "smooths out" deterministic components (by pretending they are random) and
    accounting for confounds (by explicitly modeling them in the propensity
    score).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;What if we control data collection (&lt;span class="math"&gt;\(q\)&lt;/span&gt;)?&lt;/strong&gt; This is an interesting
setting. Essentially, it asks "how do we explore/experiment optimally (and
safely)?". In general, this is an open question and depends on many
considerations, such as, how much control, exploration cost (safety constraints)
and prior knowledge (of &lt;span class="math"&gt;\(r\)&lt;/span&gt; and unknown factors in the environment). I've seen
some papers cleverly design &lt;span class="math"&gt;\(q\)&lt;/span&gt;. The first that comes to mind is
&lt;a href="https://graphics.stanford.edu/projects/gpspaper/gps_full.pdf"&gt;Levine &amp;amp; Koltun (2013)&lt;/a&gt;. Another
setting is &lt;em&gt;online&lt;/em&gt; contextual bandits, in which algorithms like
&lt;a href="http://jmlr.org/proceedings/papers/v15/beygelzimer11a/beygelzimer11a.pdf"&gt;EXP4&lt;/a&gt;
and
&lt;a href="http://www.research.rutgers.edu/~lihong/pub/Chapelle12Empirical.pdf"&gt;Thompson sampling&lt;/a&gt;,
prescribe certain types of exploration and work interactively (i.e., they don't
have a fixed training sample). Lastly, I'll mention that there are many
techniques for variance reduction by importance sampling, which may apply.&lt;/p&gt;
&lt;h2&gt;Further reading&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Léon Bottou, Jonas Peters, Joaquin Quiñonero-Candela, Denis X. Charles, D. Max
Chickering, Elon Portugaly, Dipankar Ray, Patrice Simard, Ed Snelson.
&lt;a href="https://arxiv.org/abs/1209.2355"&gt;Counterfactual reasoning in learning systems&lt;/a&gt;.
JMLR 2013.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The source for the majority of this post. It includes many other interesting
ideas and goes more in depth into some of the details.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Miroslav Dudík, John Langford, Lihong Li.
&lt;a href="https://arxiv.org/abs/1103.4601"&gt;Doubly robust policy evaluation and learning&lt;/a&gt;.
ICML 2011.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Discussed in extensions section.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Philip S. Thomas.
&lt;a href="http://psthomas.com/papers/Thomas2015c.pdf"&gt;Safe reinforcement learning&lt;/a&gt;.
PhD Thesis 2015.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Covers confidence intervals for policy evaluation similar to Bottou et al., as
well as learning algorithms for RL with safety guarantees (e.g., so we don't
break the robot).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Peshkin and Shelton.
&lt;a href="http://www.cs.ucr.edu/~cshelton/papers/docs/icml02.pdf"&gt;Learning from scarce experience&lt;/a&gt;.
ICML 2002.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;An older RL paper, which covers learning from logged data. This is one of the
earliest papers on learning from logged data that I could find.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Levine and Koltun.
&lt;a href="https://graphics.stanford.edu/projects/gpspaper/gps_full.pdf"&gt;Guided policy search&lt;/a&gt;.
ICML 2013.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Discusses clever choices for &lt;span class="math"&gt;\(q\)&lt;/span&gt; to better-guide learning in the RL setting.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Corinna Cortes, Yishay Mansour, Mehryar Mohri.
&lt;a href="https://papers.nips.cc/paper/4156-learning-bounds-for-importance-weighting.pdf"&gt;Learning bounds for importance weighting&lt;/a&gt;.
NIPS 2010.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Discusses &lt;em&gt;generalization bounds&lt;/em&gt; for the counterfactual objective. Includes an
alternative weighting scheme to keep importance weights from exploding.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="misc"></category><category term="counterfactual-reasoning"></category><category term="importance-sampling"></category><category term="machine-learning"></category></entry><entry><title>Multiclass logistic regression and conditional random fields are the same thing</title><link href="https://timvieira.github.io/blog/post/2015/04/29/multiclass-logistic-regression-and-conditional-random-fields-are-the-same-thing/" rel="alternate"></link><published>2015-04-29T00:00:00-04:00</published><updated>2015-04-29T00:00:00-04:00</updated><author><name>Tim Vieira</name></author><id>tag:timvieira.github.io,2015-04-29:/blog/post/2015/04/29/multiclass-logistic-regression-and-conditional-random-fields-are-the-same-thing/</id><content type="html">&lt;p&gt;A short rant: Multiclass logistic regression and conditional random fields (CRF)
are the same thing. This comes to a surprise to many people because CRFs tend to
be surrounded by additional "stuff."&lt;/p&gt;
&lt;p&gt;Understanding this very basic connection not only deepens our understanding, but
also suggests a method for testing complex CRF code.&lt;/p&gt;
&lt;p&gt;Multiclass logistic regression is simple. The goal is to predict the correct
label &lt;span class="math"&gt;\(y^*\)&lt;/span&gt; from handful of labels &lt;span class="math"&gt;\(\mathcal{Y}\)&lt;/span&gt; given the observation &lt;span class="math"&gt;\(x\)&lt;/span&gt; based
on features &lt;span class="math"&gt;\(\phi(x,y)\)&lt;/span&gt;. Training this model typically requires computing the
gradient:&lt;/p&gt;
&lt;div class="math"&gt;$$
\nabla \log p(y^* \mid x) = \phi(x,y^*) - \sum_{y \in \mathcal{Y}} p(y|x) \phi(x,y)
$$&lt;/div&gt;
&lt;p&gt;where
&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray*}
p(y|x) &amp;amp;=&amp;amp; \frac{1}{Z(x)} \exp(\theta^\top \phi(x,y)) &amp;amp; \ \ \ \ \text{and} \ \ \ \ &amp;amp;
Z(x) &amp;amp;=&amp;amp; \sum_{y \in \mathcal{Y}} \exp(\theta^\top \phi(x,y))
\end{eqnarray*}
$$&lt;/div&gt;
&lt;p&gt;At test-time, we often take the highest-scoring label under the model.&lt;/p&gt;
&lt;div class="math"&gt;$$
\widehat{y}(x) = \underset{y \in \mathcal{Y}}{\textrm{argmax}}\ \theta^\top \phi(x,y)
$$&lt;/div&gt;
&lt;p&gt;A conditional random field is &lt;em&gt;exactly&lt;/em&gt; multiclass logistic regression. The only
difference is that the sums (&lt;span class="math"&gt;\(Z(x)\)&lt;/span&gt; and &lt;span class="math"&gt;\(\sum_{y \in \mathcal{Y}} p(y|x)
\phi(x,y)\)&lt;/span&gt;) and the argmax &lt;span class="math"&gt;\(\widehat{y}(x)\)&lt;/span&gt; are inefficient to compute naively
(i.e., by brute-force enumeration). This point is often lost when people first
learn about CRFs. Some people never make this connection.&lt;/p&gt;
&lt;p&gt;Brute-force enumeration is a very useful method for testing complex dynamic
programming procedures for computing the sums and the argmax on relatively small
examples. Don't just copy code for dynamic programming out of a paper! Test it!&lt;/p&gt;
&lt;p&gt;Here's some stuff you'll see once we start talking about CRFs:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Inference algorithms (e.g., Viterbi decoding, forward-backward, Junction
   tree)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Graphical models (factor graphs, Bayes nets, Markov random fields)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Model templates (i.e., repeated feature functions)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the logistic regression case, we'd never use the term "inference" to describe
the "sum" and "max" over a handful of categories. Once we move to a structured
label space, this term gets throw around. (BTW, this isn't "statistical
inference," just algorithms to compute sum and max over &lt;span class="math"&gt;\(\mathcal{Y}\)&lt;/span&gt;.)&lt;/p&gt;
&lt;p&gt;Graphical models establish a notation and structural properties which allow
efficient inference&amp;mdash;things like cycles and treewidth.&lt;/p&gt;
&lt;p&gt;Model templating is the only essential trick to move from logistic regression to
a CRF. Templating "solves" the problem that not all training examples have the
same "size"&amp;mdash;the set of outputs &lt;span class="math"&gt;\(\mathcal{Y}(x)\)&lt;/span&gt; now depends on &lt;span class="math"&gt;\(x\)&lt;/span&gt;. A model
template specifies how to compute the features for an entire output, by looking
at interactions between subsets of variables.&lt;/p&gt;
&lt;div class="math"&gt;$$
\phi(x,\boldsymbol{y}) = \sum_{\alpha \in A(x)} \phi_\alpha(x,
\boldsymbol{y}_\alpha)
$$&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; is a labeled subset of variables often called a factor and
&lt;span class="math"&gt;\(\boldsymbol{y}_\alpha\)&lt;/span&gt; is the subvector containing values of variables
&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;. Basically, the feature function &lt;span class="math"&gt;\(\phi\)&lt;/span&gt; gets to look at some subset of
the variables being predicted &lt;span class="math"&gt;\(y\)&lt;/span&gt; and the entire input &lt;span class="math"&gt;\(x\)&lt;/span&gt;. The ability to look
at more of &lt;span class="math"&gt;\(y\)&lt;/span&gt; allows the model to make more coherent predictions.&lt;/p&gt;
&lt;p&gt;Anywho, it's often useful to take a step back and think about what you are
trying to compute instead of how you're computing it. In this post, this allowed
us see the similarity between logistic regression and CRFs even though they seem
quite different.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="misc"></category><category term="machine-learning"></category><category term="rant"></category><category term="crf"></category></entry><entry><title>Conditional random fields as deep learning models?</title><link href="https://timvieira.github.io/blog/post/2015/02/05/conditional-random-fields-as-deep-learning-models/" rel="alternate"></link><published>2015-02-05T00:00:00-05:00</published><updated>2015-02-05T00:00:00-05:00</updated><author><name>Tim Vieira</name></author><id>tag:timvieira.github.io,2015-02-05:/blog/post/2015/02/05/conditional-random-fields-as-deep-learning-models/</id><content type="html">&lt;p&gt;This post is intended to convince conditional random field (CRF) lovers that
deep learning might not be as crazy as it seems. And maybe even convince some
deep learning lovers that the graphical models might have interesting things to
offer.&lt;/p&gt;
&lt;p&gt;In the world of structured prediction, we are plagued by the high-treewidth
problem -- models with loopy factors are "bad" because exact inference is
intractable. There are three common approaches for dealing with this problem:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Limit the expressiveness of the model (i.e., don't use to model you want)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change the training objective&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Approximate inference&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Approximate inference is tricky. Things can easily go awry.&lt;/p&gt;
&lt;p&gt;For example, structured perceptron training with loopy max-product BP instead of
exact max product can diverge
&lt;a href="http://papers.nips.cc/paper/3162-structured-learning-with-approximate-inference.pdf"&gt;(Kulesza &amp;amp; Pereira, 2007)&lt;/a&gt;. Another
example: using approximate marginals from sum-product loopy BP in place of the
true marginals in the gradient of the log-likelihood. This results in a
different nonconvex objective function. (Note:
&lt;a href="http://aclweb.org/anthology/C/C12/C12-1122.pdf"&gt;sometimes&lt;/a&gt; these loopy BP
approximations work fine.)&lt;/p&gt;
&lt;p&gt;It looks like using approximate inference during training changes the training
objective.&lt;/p&gt;
&lt;p&gt;So, here's a simple idea: learn a model which makes accurate predictions given
the approximate inference algorithm that will be used at test-time. Furthermore,
we should minimize empirical risk instead of log-likelihood because it is robust
to model miss-specification and approximate inference. In other words, make
training conditions as close as possible to test-time conditions.&lt;/p&gt;
&lt;p&gt;Now, as long as everything is differentiable, you can apply automatic
differentiation (backprop) to train the end-to-end system. This idea appears in
a few publications, including a handful of papers by Justin Domke, and a few by
Stoyanov &amp;amp; Eisner.&lt;/p&gt;
&lt;p&gt;Unsuprisingly, it works pretty well.&lt;/p&gt;
&lt;p&gt;I first saw this idea in
&lt;a href="http://proceedings.mlr.press/v15/stoyanov11a/stoyanov11a.pdf"&gt;Stoyanov &amp;amp; Eisner (2011)&lt;/a&gt;. They
use loopy belief propagation as their approximate inference algorithm. At the
end of the day, their model is essentially a deep recurrent network, which came
from unrolling inference in a graphical model. This idea really struck me
because it's clearly right in the middle between graphical models and deep
learning.&lt;/p&gt;
&lt;p&gt;You can immediately imagine swapping in other approximate inference algorithms
in place of loopy BP.&lt;/p&gt;
&lt;p&gt;Deep learning approaches get a bad reputation because there are a lot of
"tricks" to get nonconvex optimization to work and because model structures are
more open ended. Unlike graphical models, deep learning models have more
variation in model structures. Maybe being more open minded about model
structures is a good thing. We seem to have hit a brick wall with
likelihood-based training. At the same time, maybe we can port over some of the
good work on approximate inference as deep architectures.&lt;/p&gt;</content><category term="misc"></category><category term="machine-learning"></category><category term="deep-learning"></category><category term="structured-prediction"></category></entry><entry><title>KL-divergence as an objective function</title><link href="https://timvieira.github.io/blog/post/2014/10/06/kl-divergence-as-an-objective-function/" rel="alternate"></link><published>2014-10-06T00:00:00-04:00</published><updated>2014-10-06T00:00:00-04:00</updated><author><name>Tim Vieira</name></author><id>tag:timvieira.github.io,2014-10-06:/blog/post/2014/10/06/kl-divergence-as-an-objective-function/</id><content type="html">&lt;p&gt;It's well-known that
&lt;a href="http://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence"&gt;KL-divergence&lt;/a&gt;
is not symmetric, but which direction is right for fitting your model?&lt;/p&gt;
&lt;h4&gt;Which KL is which? A cheat sheet&lt;/h4&gt;
&lt;p&gt;If we're fitting &lt;span class="math"&gt;\(q_\theta\)&lt;/span&gt; to &lt;span class="math"&gt;\(p\)&lt;/span&gt; using&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\textbf{KL}(p || q_\theta)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mean-seeking, &lt;em&gt;inclusive&lt;/em&gt; (more principled because approximates the &lt;em&gt;full&lt;/em&gt; distribution)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;requires normalization wrt &lt;span class="math"&gt;\(p\)&lt;/span&gt; (i.e., often &lt;em&gt;not&lt;/em&gt; computationally convenient)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\textbf{KL}(q_\theta || p)\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mode-seeking, &lt;em&gt;exclusive&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;no normalization wrt &lt;span class="math"&gt;\(p\)&lt;/span&gt; (i.e., computationally convenient)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Mnemonic&lt;/strong&gt;: "When the truth comes first, you get the whole truth" (h/t
&lt;a href="https://www.umiacs.umd.edu/~resnik/"&gt;Philip Resnik&lt;/a&gt;). Here "whole truth"
corresponds to the &lt;em&gt;inclusiveness&lt;/em&gt; of &lt;span class="math"&gt;\(\textbf{KL}(p || q)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;As far as remembering the equation, I pretend that "&lt;span class="math"&gt;\(||\)&lt;/span&gt;" is a division symbol,
which happens to correspond nicely to a division symbol in the equation (I'm not
sure it's intentional).&lt;/p&gt;
&lt;h2&gt;Inclusive vs. exclusive divergence&lt;/h2&gt;
&lt;div style="background-color: #f2f2f2; border: 2px solid #ggg; padding: 10px;"&gt;

&lt;img src="http://timvieira.github.io/blog/images/KL-inclusive-exclusive.png" /&gt;
Figure by &lt;a href="http://www.johnwinn.org/"&gt;John Winn&lt;/a&gt;.
&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;Computational perspecive&lt;/h2&gt;
&lt;p&gt;Let's look at what's involved in fitting a model &lt;span class="math"&gt;\(q_\theta\)&lt;/span&gt; in each
direction. In this section, I'll describe the gradient and pay special attention
to the issue of normalization.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notation&lt;/strong&gt;: &lt;span class="math"&gt;\(p,q_\theta\)&lt;/span&gt; are probabilty distributions. &lt;span class="math"&gt;\(p = \bar{p} / Z_p\)&lt;/span&gt;,
where &lt;span class="math"&gt;\(Z_p\)&lt;/span&gt; is the normalization constant. Similarly for &lt;span class="math"&gt;\(q\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;The easy direction &lt;span class="math"&gt;\(\textbf{KL}(q_\theta || p)\)&lt;/span&gt;&lt;/h3&gt;
&lt;div class="math"&gt;\begin{align*}
\textbf{KL}(q_\theta || p)
&amp;amp;= \sum_d q(d) \log \left( \frac{q(d)}{p(d)} \right) \\
&amp;amp;= \sum_d q(d) \left( \log q(d) - \log p(d) \right) \\
&amp;amp;= \underbrace{\sum_d q(d) \log q(d)}_{-\text{entropy}} - \underbrace{\sum_d q(d) \log p(d)}_{\text{cross-entropy}} \\
\end{align*}&lt;/div&gt;
&lt;p&gt;Let's look at normalization of &lt;span class="math"&gt;\(p\)&lt;/span&gt;, the entropy term is easy because there is no &lt;span class="math"&gt;\(p\)&lt;/span&gt; in it.
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\sum_d q(d) \log p(d)
&amp;amp;= \sum_d q(d) \log (\bar{p}(d) / Z_p) \\
&amp;amp;= \sum_d q(d) \left( \log \bar{p}(d) - \log Z_p) \right) \\
&amp;amp;= \sum_d q(d) \log \bar{p}(d) - \sum_d q(d) \log Z_p \\
&amp;amp;= \sum_d q(d) \log \bar{p}(d) - \log Z_p
\end{align*}&lt;/div&gt;
&lt;p&gt;In this case, &lt;span class="math"&gt;\(-\log Z_p\)&lt;/span&gt; is an additive constant, which can be dropped because
we're optimizing.&lt;/p&gt;
&lt;p&gt;This leaves us with the following optimization problem:
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
&amp;amp; \underset{\theta}{\text{argmin}}\, \textbf{KL}(q_\theta || p) \\
&amp;amp;\qquad = \underset{\theta}{\text{argmin}}\, \sum_d q_\theta(d) \log q_\theta(d) - \sum_d q_\theta(d) \log \bar{p}(d)
\end{align*}&lt;/div&gt;
&lt;p&gt;Let's work out the gradient
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
&amp;amp; \nabla\left[ \sum_d q_\theta(d) \log q_\theta(d) - \sum_d q_\theta(d) \log \bar{p}(d) \right] \\
&amp;amp;\qquad = \sum_d \nabla \left[ q_\theta(d) \log q_\theta(d) \right] - \sum_d \nabla\left[ q_\theta(d) \right] \log \bar{p}(d) \\
&amp;amp;\qquad = \sum_d \nabla \left[ q_\theta(d) \right] \left( 1 + \log q_\theta(d) \right) - \sum_d \nabla\left[ q_\theta(d) \right] \log \bar{p}(d) \\
&amp;amp;\qquad = \sum_d \nabla \left[ q_\theta(d) \right] \left( 1 + \log q_\theta(d) - \log \bar{p}(d) \right) \\
&amp;amp;\qquad = \sum_d \nabla \left[ q_\theta(d) \right] \left( \log q_\theta(d) - \log \bar{p}(d) \right) \\
\end{align*}&lt;/div&gt;
&lt;p&gt;We killed the one in the last equality because &lt;span class="math"&gt;\(\sum_d \nabla
\left[ q(d) \right] = \nabla \left[ \sum_d q(d) \right] = \nabla
\left[ 1 \right] = 0\)&lt;/span&gt;, for any &lt;span class="math"&gt;\(q\)&lt;/span&gt; which is a probability distribution.&lt;/p&gt;
&lt;p&gt;This direction is convenient because we don't need to normalize
&lt;span class="math"&gt;\(p\)&lt;/span&gt;. Unfortunately, the "easy" direction is nonconvex in general&amp;mdash;unlike
the "hard" direction, which (as we'll see shortly) is convex.&lt;/p&gt;
&lt;h3&gt;Harder direction &lt;span class="math"&gt;\(\textbf{KL}(p || q_\theta)\)&lt;/span&gt;&lt;/h3&gt;
&lt;div class="math"&gt;\begin{align*}
\textbf{KL}(p || q_\theta)
&amp;amp;= \sum_d p(d) \log \left( \frac{p(d)}{q(d)} \right) \\
&amp;amp;= \sum_d p(d) \left( \log p(d) - \log q(d) \right) \\
&amp;amp;= \sum_d p(d) \log p(d) - \sum_d p(d) \log q(d) \\
\end{align*}&lt;/div&gt;
&lt;p&gt;Clearly the first term (entropy) won't matter if we're just trying optimize wrt
&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;. So, let's focus on the second term (cross-entropy).
&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\sum_d p(d) \log q(d)
&amp;amp;= \frac{1}{Z_p} \sum_d \bar{p}(d) \log \left( \bar{q}(d)/Z_q \right) \\
&amp;amp;= \frac{1}{Z_p} \sum_d \bar{p}(d) \left( \log \bar{q}(d) - \log Z_q \right) \\
&amp;amp;= \left(\frac{1}{Z_p} \sum_d \bar{p}(d) \log \bar{q}(d)\right) - \left(\frac{1}{Z_p} \sum_d \bar{p}(d) \log Z_q\right) \\
&amp;amp;= \left(\frac{1}{Z_p} \sum_d \bar{p}(d) \log \bar{q}(d)\right) - \left( \log Z_q \right) \left( \frac{1}{Z_p} \sum_d \bar{p}(d)\right) \\
&amp;amp;= \left(\frac{1}{Z_p} \sum_d \bar{p}(d) \log \bar{q}(d)\right) - \log Z_q
\end{align*}&lt;/div&gt;
&lt;p&gt;The gradient, when &lt;span class="math"&gt;\(q\)&lt;/span&gt; is in the exponential family, is intuitive:&lt;/p&gt;
&lt;div class="math"&gt;\begin{align*}
\nabla \left[ \frac{1}{Z_p} \sum_d \bar{p}(d) \log \bar{q}(d) - \log Z_q \right]
&amp;amp;= \frac{1}{Z_p} \sum_d \bar{p}(d) \nabla \left[ \log \bar{q}(d) \right] - \nabla \log Z_q \\
&amp;amp;= \frac{1}{Z_p} \sum_d \bar{p}(d) \phi_q(d) - \mathbb{E}_q \left[ \phi_q \right] \\
&amp;amp;= \mathbb{E}_p \left[ \phi_q \right] - \mathbb{E}_q \left[ \phi_q \right]
\end{align*}&lt;/div&gt;
&lt;p&gt;Why do we say this is hard to compute? Well, for most interesting models, we
can't compute &lt;span class="math"&gt;\(Z_p = \sum_d \bar{p}(d)\)&lt;/span&gt;. This is because &lt;span class="math"&gt;\(p\)&lt;/span&gt; is presumed to be a
complex model (e.g., the real world, an intricate factor graph, a complicated
Bayesian posterior). If we can't compute &lt;span class="math"&gt;\(Z_p\)&lt;/span&gt;, it's highly unlikely that we can
compute another (nontrivial) integral under &lt;span class="math"&gt;\(\bar{p}\)&lt;/span&gt;, e.g., &lt;span class="math"&gt;\(\sum_d \bar{p}(d)
\log \bar{q}(d)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Nonetheless, optimizing KL in this direction is still useful. Examples include:
expectation propagation, variational decoding, and maximum likelihood
estimation. In the case of maximum likelihood estimation, &lt;span class="math"&gt;\(p\)&lt;/span&gt; is the empirical
distribution, so technically you don't have to compute its normalizing constant,
but you do need samples from it, which can be just as hard to get as computing a
normalization constant.&lt;/p&gt;
&lt;p&gt;Optimization problem is &lt;em&gt;convex&lt;/em&gt; when &lt;span class="math"&gt;\(q_\theta\)&lt;/span&gt; is an exponential
family&amp;mdash;i.e., for any &lt;span class="math"&gt;\(p\)&lt;/span&gt; the &lt;em&gt;optimization&lt;/em&gt; problem is "easy." You can
think of maximum likelihood estimation (MLE) as a method which minimizes KL
divergence based on samples of &lt;span class="math"&gt;\(p\)&lt;/span&gt;. In this case, &lt;span class="math"&gt;\(p\)&lt;/span&gt; is the true data
distribution! The first term in the gradient is based on a sample instead of an
exact estimate (often called "observed feature counts"). The downside, of
course, is that computing &lt;span class="math"&gt;\(\mathbb{E}_p \left[ \phi_q \right]\)&lt;/span&gt; might not be
tractable or, for MLE, require tons of samples.&lt;/p&gt;
&lt;h2&gt;Remarks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;In many ways, optimizing exclusive KL makes no sense at all! Except for the
  fact that it's computable when inclusive KL is often not. Exclusive KL is
  generally regarded as "an approximation" to inclusive KL. This bias in this
  approximation can be quite large.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inclusive vs. exclusive is an important distinction: Inclusive divergences
  require &lt;span class="math"&gt;\(q &amp;gt; 0\)&lt;/span&gt; whenever &lt;span class="math"&gt;\(p &amp;gt; 0\)&lt;/span&gt; (i.e., no "false negatives"), whereas
  exclusive divergences favor a single mode (i.e., only a good fit around a that
  mode).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;When &lt;span class="math"&gt;\(q\)&lt;/span&gt; is an exponential family, &lt;span class="math"&gt;\(\textbf{KL}(p || q_\theta)\)&lt;/span&gt; will be convex
  in &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;, no matter how complicated &lt;span class="math"&gt;\(p\)&lt;/span&gt; is, whereas &lt;span class="math"&gt;\(\textbf{KL}(q_\theta
  || p)\)&lt;/span&gt; is generally nonconvex (e.g., if &lt;span class="math"&gt;\(p\)&lt;/span&gt; is multimodal).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Computing the value of either KL divergence requires normalization. However,
  in the "easy" (exclusive) direction, we can optimize KL without computing
  &lt;span class="math"&gt;\(Z_p\)&lt;/span&gt; (as it results in only an additive constant difference).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Both directions of KL are special cases of
  &lt;a href="https://en.wikipedia.org/wiki/R%C3%A9nyi_entropy"&gt;&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;-divergence&lt;/a&gt;. For a
  unified account of both directions consider looking into &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;-divergence.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Acknowledgments&lt;/h3&gt;
&lt;p&gt;I'd like to thank the following people:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://twitter.com/ryandcotterell"&gt;Ryan Cotterell&lt;/a&gt; for an email exchange
  which spawned this article.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://twitter.com/adveisner"&gt;Jason Eisner&lt;/a&gt; for teaching me all this stuff.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://twitter.com/florian_shkurti"&gt;Florian Shkurti&lt;/a&gt; for a useful email
  discussion, which caugh a bug in my explanation of why inclusive KL is hard to
  compute/optimize.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://twitter.com/sjmielke"&gt;Sabrina Mielke&lt;/a&gt; for the suggesting the
  "inclusive vs. exclusive" figure.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="misc"></category><category term="statistics"></category><category term="machine-learning"></category><category term="structured-prediction"></category></entry></feed>